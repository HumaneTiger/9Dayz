import { default as Audio } from './audio.js';
import { default as Props } from './props.js';
import { default as Player } from './player.js';
import { default as Cards } from './cards.js';
import { default as Map } from './map.js';
import { default as Cooking } from './cooking.js';
import { default as Character } from './character.js';
import RecipeDefinitions from '../data/definitions/recipe-definitions.js';
import TimingUtils from './utils/timing-utils.js';

const cardsContainer = document.getElementById('cards');

let smallTreeCounter = 1,
  bigTreeCounter = 1,
  fieldCounter = 1;

export default {
  init: function () {},

  createCardMarkup: function (id) {
    let object = Props.getObject(id);
    let cardMarkupExtension;
    let buildingName = object.name.startsWith('signpost-') ? 'signpost' : object.name;

    if (object.name === 'small-tree') {
      buildingName = buildingName + '-' + smallTreeCounter;
      smallTreeCounter === 1 ? (smallTreeCounter = 2) : (smallTreeCounter = 1);
    } else if (object.name === 'big-tree') {
      buildingName = buildingName + '-' + bigTreeCounter;
      bigTreeCounter === 1 ? (bigTreeCounter = 2) : (bigTreeCounter = 1);
    } else if (object.name === 'field') {
      buildingName = buildingName + '-' + fieldCounter;
      fieldCounter === 1 ? (fieldCounter = 2) : (fieldCounter = 1);
    }

    let cardMarkupPre =
      `<div id="${id}" class="card ${object.locked ? 'locked ' : ''} ${object.dead ? 'dead ' : ''} ${object.preview ? 'preview ' : ''} ${object.group}" style="left: ${Math.round(object.x * 44.4 - 120)}px; top: 600px; transform: scale(0.4);">` +
      `<div class="inner">`;

    let cardMarkupBuilding =
      `<div class="status"><div class="status-locked"></div><div class="status-zombies"></div><div class="status-looted"></div><div class="status-infested ${buildingName === 'beehive' ? 'bees' : ''}"></div></div>` +
      `<h2>${object.title}</h2>` +
      `<p class="activity glow is--hidden"></p>` +
      `<img class="motive" src="./img/buildings/${buildingName}.png">` +
      `<div class="banner"><img src="./img/icons/buildings/${object.type}.png"></div>` +
      `<div class="dead"><img src="./img/ui/preview.png"></div>`;

    let cardMarkupZombie =
      `<div class="attack">${object.attack}</div><div class="health">${object.defense}</div>` +
      `<p class="activity glow is--hidden"></p>` +
      `<img class="motive" src="./img/zombies/${object.name}.png">` +
      `<div class="dead"><img src="./img/zombies/${object.name === 'rat' || object.name === 'bee' ? 'dead' : 'undead'}.png"></div>`;

    let cardMarkupWeapon =
      `<div class="attack">${object.attack}</div><div class="shield">${object.defense}</div>` +
      `<p class="activity glow is--hidden"></p>` +
      `<img class="motive" src="./img/weapons/${object.name}.png">` +
      `<div class="banner"><img src="./img/icons/weapons/${object.group}.png"></div>`;

    let cardMarkupAnimal =
      `<p class="activity glow is--hidden"></p>` +
      `<img class="motive" src="./img/animals/${object.name === 'fish' ? object.name + '-' + Math.floor(Math.random() * 3 + 1) : object.name}.png">` +
      `<div class="banner"><img src="./img/icons/animals/animal.png"></div>` +
      `<div class="dead"><img src="./img/zombies/dead.png"></div>`;

    let cardMarkupEvent = `<h2>${object.title}</h2>` + `<p class="text">${object.text}</p>`;

    let cardMarkupPost =
      `</div>` +
      `<span class="distance">${object.distance > 1 ? Math.round(object.distance * 4.4) + ' min' : 'Here'}</span>` +
      `</div>`;

    if (object.name === 'fireplace') {
      cardMarkupExtension = '<ul class="cooking">';
      const cookingRecipes = RecipeDefinitions.cookingRecipes;
      for (const recipe in cookingRecipes) {
        cardMarkupExtension += '<li>';
        cardMarkupExtension +=
          '<div class="slot unknown item-' +
          cookingRecipes[recipe][0] +
          '" data-item="' +
          cookingRecipes[recipe][0] +
          '"><img src="./img/items/' +
          cookingRecipes[recipe][0] +
          '.PNG" class="bg"><span class="unknown">?</span><span class="amount"></span></div>';
        cardMarkupExtension += '<div class="slot operator"><span class="sign">+</span></div>';
        cardMarkupExtension +=
          '<div class="slot unknown item-' +
          cookingRecipes[recipe][1] +
          '" data-item="' +
          cookingRecipes[recipe][1] +
          '"><img src="./img/items/' +
          cookingRecipes[recipe][1] +
          '.PNG" class="bg"><span class="unknown">?</span><span class="amount"></span></div>';
        cardMarkupExtension += '<div class="slot operator"><span class="sign">=</span></div>';
        cardMarkupExtension +=
          '<div class="slot action unknown item-' +
          recipe +
          '" data-item="' +
          recipe +
          '"><img src="./img/items/' +
          recipe +
          '.PNG" class="bg"><span class="unknown">?</span><span class="amount">' +
          cookingRecipes[recipe][2] +
          '</span><span class="action">' +
          cookingRecipes[recipe][3] +
          '</span></div>';
        cardMarkupExtension += '</li>';
      }
      cardMarkupExtension +=
        '<li class="action"><div class="action-button" data-action="close-cooking"><span class="text">Back</span></div></li>';
      cardMarkupExtension += '</ul>';
    }

    // generate action markup
    let actionList = '';
    object.actions?.forEach(action => {
      let additionInfo = '';
      let label = action.label;

      if (action.time || action.energy) {
        additionInfo = '<span class="additional">';
        if (action.time) {
          additionInfo += action.time + ' min';
        }
        if (action.energy) {
          additionInfo += ' | ' + (action.energy > 0 ? '+' : '') + action.energy;
          if (action.id === 'rest') {
            additionInfo += '<span class="at-night">(+5)</span>';
          } else if (action.id === 'sleep') {
            additionInfo += '<span class="at-night">(+20)</span>';
          }
          additionInfo += '<span class="material-symbols-outlined energy">flash_on</span>';
        }
        additionInfo += '</span>';
      }
      if (action.id === 'rest' || action.id === 'sleep') {
        label =
          '<span class="material-symbols-outlined nightmode at-night">dark_mode</span> ' + label;
      }

      actionList +=
        '<li class="' +
        action.id +
        '"><div data-action="' +
        action.id +
        '" class="action-button">' +
        '<span class="text">' +
        label +
        '</span>' +
        additionInfo +
        '<span class="additional-locked"></span></div></li>';
    });

    // generate item markup
    let itemMarkup = '';

    for (var i = 0; i < object.items.length; i += 1) {
      itemMarkup += this.generateItemMarkup(object.items[i].name, object.items[i].amount);
    }

    // compile card markup

    let cardMarkup = cardMarkupPre;

    switch (object.group) {
      case 'building':
        cardMarkup += cardMarkupBuilding;
        break;
      case 'zombie':
        cardMarkup += cardMarkupZombie;
        break;
      case 'event':
        cardMarkup += cardMarkupEvent;
        break;
      case 'weapon':
        cardMarkup += cardMarkupWeapon;
        break;
      case 'animal':
        cardMarkup += cardMarkupAnimal;
        break;
    }

    if (object.actions.length) {
      cardMarkup = cardMarkup + '<ul class="actions">' + actionList + '</ul>';
    }

    // only cooking for now
    if (cardMarkupExtension) {
      cardMarkup += cardMarkupExtension;
    }

    if (object.items.length) {
      cardMarkup = cardMarkup + '<ul class="items is--hidden">' + itemMarkup + '</ul>';
    }

    cardMarkup += cardMarkupPost;

    cardsContainer.innerHTML += cardMarkup;
  },

  generateItemMarkup: function (name, amount) {
    const props = Props.calcItemProps(name);
    /* a new building state "itemsReveald" is missing */
    /* after gathering + save + reload, items are hidden again */
    return (
      '<li class="preview"><span class="unknown">?</span><div class="searching is--hidden"><div></div><div></div></div></li>' +
      '<li class="item is--hidden" data-item="' +
      name +
      '" data-amount="' +
      amount +
      '">' +
      '<span class="img">' +
      (props?.type !== 'extra'
        ? '<img src="./img/items/' + name + '.PNG">'
        : '<img class="weapon" src="./img/weapons/' + name + '.png">') +
      '</span><span class="amount">' +
      (amount > 1 ? amount : '') +
      '</span><span class="grab">Grab</span></li>'
    );
  },

  moveNewCardIntoPlace: async function (cardId, index, sharedDeckState) {
    const Z_INDEX_BASE = 200;
    const CARD_WIDTH = 380 * 0.7;
    const cardRef = document.getElementById(cardId);

    if (!cardRef) return;

    // card is already visible at it's source position
    // it just waits a little until it shifts into the deck
    await TimingUtils.wait(300 + 100 * index);

    sharedDeckState.activeCardIndex += 1;

    if (cardRef.style.top === '600px') {
      cardRef.style.top = '';
      Audio.sfx('deal-card');
    }
    if (!cardRef.classList.contains('fight')) {
      if (cardRef.style.left !== sharedDeckState.cardLeftPosition + 'px') {
        cardRef.style.transform = '';
        cardRef.style.left = sharedDeckState.cardLeftPosition + 'px';
        cardRef.style.zIndex = Z_INDEX_BASE - sharedDeckState.activeCardIndex;
        delete cardRef.dataset.oldZindex;
      }
    }
    if (sharedDeckState.activeCardIndex < 14) {
      cardRef.classList.remove('out-of-queue');
      if (sharedDeckState.activeCardDeckSize < 7) {
        sharedDeckState.cardLeftPosition += Math.floor(CARD_WIDTH);
      } else if (sharedDeckState.activeCardDeckSize < 10) {
        if (sharedDeckState.activeCardIndex < 3) {
          sharedDeckState.cardLeftPosition += Math.floor(CARD_WIDTH);
        } else {
          sharedDeckState.cardLeftPosition += Math.floor(
            CARD_WIDTH - sharedDeckState.activeCardIndex * 10
          );
        }
      } else {
        let additionalLeft = Math.floor(CARD_WIDTH - (sharedDeckState.activeCardIndex + 1.5) * 15);
        if (additionalLeft < 100) {
          additionalLeft = 100;
        }
        sharedDeckState.cardLeftPosition += additionalLeft;
      }
    } else if (!cardRef.classList.contains('fight')) {
      cardRef.classList.add('out-of-queue');
    }
  },

  handleCardStates: function (cardId) {
    const object = Props.getObject(cardId);
    const cardRef = document.getElementById(cardId);

    if (object.locked) {
      cardRef.classList.add('locked');
    } else {
      cardRef.classList.remove('locked');
    }
    // need object prop for 'lootable', can also be used in props.js for action combos that make no sense
    if (
      object.looted &&
      !(
        object.name.startsWith('signpost') ||
        object.name === 'fireplace' ||
        object.name === 'bee' ||
        object.name === 'key'
      )
    ) {
      // mega bug: when bees contains no item from the beginning (amount=0), ul.item will be removed and cut/gather/search won't work
      // maybe next line can be removed? or is--hidden can be added?
      cardRef.querySelector('ul.items')?.remove();
      cardRef.querySelector('div.banner')?.classList.remove('is--hidden');
      cardRef.classList.add('looted');
    } else {
      cardRef.classList.remove('looted');
    }
    if (object.infested) {
      cardRef.classList.add('infested');
    } else {
      cardRef.classList.remove('infested');
    }
    if (object.zednearby) {
      cardRef.classList.add('zombieshere');
    } else {
      cardRef.classList.remove('zombieshere');
    }
    if (object.distance > 1) {
      cardRef.querySelector('.distance').textContent = Math.round(object.distance * 4.4) + ' min';
      if (!object.inreach) Cooking.end(cardRef);
    } else {
      cardRef.querySelector('.distance').textContent = 'Here';
    }
    cardRef.classList.remove('is--hidden');
  },

  deactivateCard: async function (cardId) {
    await TimingUtils.wait(300);

    const object = Props.getObject(cardId);
    const cardRef = document.getElementById(cardId);
    if (!cardRef) return;

    cardRef.style.left = Math.round(parseInt(object.x) * 44.4 - 120) + 'px';
    cardRef.style.top = '600px';
    cardRef.style.transform = 'scale(0.4)';
    cardRef.style.opacity = 0;

    await TimingUtils.wait(300);

    if (object.group === 'event') {
      object.removed = true;
    } else {
      cardRef.classList.add('is--hidden');
      cardRef.style.opacity = 1;
    }
  },

  updateCardActions: function (cardId) {
    const object = Props.getObject(cardId);
    const cardRef = document.getElementById(cardId);

    object.actions?.forEach(action => {
      let actionRef = cardRef.querySelector('ul.actions li.' + action.id);
      if (action.locked) {
        if (!object.inreach) {
          actionRef.querySelector('.additional-locked').textContent = 'Too far away';
        } else if (action.energy && Player.getProp('energy') + action.energy < 0) {
          actionRef.querySelector('.additional-locked').textContent =
            Math.abs(action.energy) + ' energy needed';
        } else if (object.zednearby) {
          actionRef.querySelector('.additional-locked').textContent = 'Hostiles nearby';
        } else if (object.infested && (action.id === 'rest' || action.id === 'sleep')) {
          actionRef.querySelector('.additional-locked').textContent = 'Infested';
        } else if (action.id === 'cut-down' || action.id === 'break-door') {
          actionRef.querySelector('.additional-locked').textContent = 'Axe needed';
        } else if (action.id === 'unlock-door') {
          actionRef.querySelector('.additional-locked').textContent = 'Key needed';
        } else if (action.id === 'cut') {
          actionRef.querySelector('.additional-locked').textContent = 'Knife needed';
        } else if (action.id === 'smash-window') {
          actionRef.querySelector('.additional-locked').textContent = 'Axe or Stone needed';
        } else if (action.id === 'fish') {
          actionRef.querySelector('.additional-locked').textContent = 'Fishing rod needed';
        } else if (action.id === 'equip') {
          if (Character.numberFilledSlots() >= 2) {
            actionRef.querySelector('.additional-locked').textContent = 'No free space';
          } else {
            actionRef.querySelector('.additional-locked').textContent = 'Can carry only one';
          }
        } else {
          actionRef.querySelector('.additional-locked').textContent = 'Locked';
        }
        actionRef.classList.add('locked');
      } else {
        actionRef.classList.remove('locked');
      }
      if (
        (action.id === 'search' || action.id === 'cut') &&
        (object.dead === false || object.locked === true)
      ) {
        actionRef.classList.add('is--hidden');
      } else {
        actionRef.classList.remove('is--hidden');
      }
      // doggy card spawns new when dead, so here is the safest place to remove the actions
      if (object.dead && object.name === 'doggy') {
        Cards.removeAction('pet', cardRef, object);
        Cards.removeAction('scare', cardRef, object);
      }
      if (action.critical) {
        actionRef.classList.add('critical');
        actionRef.querySelector('span.text').innerHTML =
          '<span class="material-symbols-outlined alert">release_alert</span> ' + action.label;
      } else {
        actionRef.classList.remove('critical');
        actionRef.querySelector('span.text').innerHTML = action.label;
      }
      if (action.id === 'chomp' && !Props.getCompanion().active) {
        actionRef.querySelector('.additional-locked').textContent = 'Doggy needed';
      }
    });
  },

  removeCard: async function (cardId) {
    const cardRef = document.getElementById(cardId);
    if (!cardRef) return;

    Map.removeObjectIconById(cardId);

    cardRef.classList.add('remove');
    await TimingUtils.wait(300);
    cardRef.remove();
  },

  setCardDeckVerticalPosition: function () {
    const playerPosition = Player.getPlayerPosition();

    // decide position top or bottom
    if (playerPosition.y < 15) {
      cardsContainer.classList.add('cards-at-bottom');
      document.getElementById('character')?.classList.add('character-at-top');
    } else {
      cardsContainer.classList.remove('cards-at-bottom');
      document.getElementById('character')?.classList.remove('character-at-top');
    }
  },

  getActiveCardDeckSize: function (cardDeck) {
    let activeCardDeckSize = 0;

    for (const card of cardDeck || []) {
      const object = Props.getObject(card.id);
      if (!object.removed && object.active) {
        activeCardDeckSize += 1;
      }
    }

    return activeCardDeckSize;
  },

  updateCardDeckMarkup: function (cardDeck) {
    if (!cardDeck || cardDeck.length === 0) return;

    const sharedDeckState = {
      activeCardDeckSize: this.getActiveCardDeckSize(cardDeck),
      activeCardIndex: 0,
      cardLeftPosition: 0,
    };

    this.setCardDeckVerticalPosition();

    for (let i = 0; i < cardDeck.length; i++) {
      const card = cardDeck[i];
      const cardId = card.id;
      const object = Props.getObject(cardId);

      if (!object.removed) {
        if (object.active) {
          // move new cards into place
          this.moveNewCardIntoPlace(cardId, i, sharedDeckState);
          // handle several card states like locked, looted, infested, distance
          this.handleCardStates(cardId);
        }

        // deactivate cards
        if (!object.active) {
          this.deactivateCard(cardId);
        }
      }

      // update actions
      this.updateCardActions(cardId);

      if (object.removed) {
        this.removeCard(cardId);
      }
    }
  },

  showActionFeedback: function (cardId, actionLabel) {
    const cardRef = Cards.getCardById(cardId);
    if (cardRef) {
      /* hide actions and show feedback */
      cardRef.querySelector('div.banner')?.classList.add('is--hidden');
      cardRef.querySelector('ul.actions')?.classList.add('is--hidden');
      if (cardRef.querySelector('p.activity') !== null) {
        cardRef.querySelector('p.activity').textContent = actionLabel;
        cardRef.querySelector('p.activity')?.classList.remove('is--hidden');
        /* hide "dead" banner while activity is shown */
        cardRef.querySelector('div.dead')?.classList.add('is--hidden');
      }
    }
  },

  hideActionFeedback: function (cardRef) {
    if (cardRef) {
      if (cardRef.querySelector('p.activity')) {
        cardRef.querySelector('p.activity').textContent = '';
        cardRef.querySelector('p.activity').classList.add('is--hidden');
        /* show "dead" banner when activity has finished */
        cardRef.querySelector('div.dead')?.classList.remove('is--hidden');
      }
      cardRef.querySelector('ul.actions')?.classList.remove('is--hidden');
      if (cardRef.querySelector('ul.items')?.classList.contains('is--hidden')) {
        cardRef.querySelector('div.banner')?.classList.remove('is--hidden');
      }
    }
  },
};
